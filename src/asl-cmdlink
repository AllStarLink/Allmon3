# Wrapper for asl_cmd_response to handle ACTION:COMMAND
def asl_cmd(s, cmdstr):
	log.debug("enter asl_cmd()")
	
	try:
		cmd = "ACTION: COMMAND\r\nCOMMAND: {}\r\n".format(cmdstr)
		c_response = asl_cmd_response(s, cmd)

		# For Asterisk 20/ASL3 look for Output:
		if  re.match(r"^Response\:\s+Error\s", c_response):
			output = re.search(r"^.*Output:\s+(.*)", c_response, re.MULTILINE)
			if(output):
				return "ERR: {}".format(output.group(1))

		# For Asterisk 20/ASL3 we look for Output: lines
		if  re.match(r"^Response\:\s+Success\s", c_response):
			output = re.split("\r\n", c_response)
			r = "OK:\r\n"
			for l in output:
				if re.match(r"^Output:\s", l):
					output = re.search(r"^Output:\s(.*)$", l)
					log.debug(output.group(1))
					r += output.group(1) + "\r\n"
			return r

		# For Asterisk 1.4/Classic ASL we have to assume the ordering
		# and there's no valid command check
		if  re.match(r"^Response\:\s+Follows\s", c_response):
			output = re.split("\r\n", c_response)
			log.debug(output[3])
			if not re.match(r"No such command", output[3]) and not re.match(r"Unknown action name", output[3]):
				return "OK:\r\n{}".format(output[3])
			
			return "ERR:\r\n{}".format(output[3])

		return "ERR: command output responded with something I didn't understand"

	except Exception as e:
		log.error("asl_cmd() exception %s", e.__class__)
		log.error("asl_cmd() message %s", e.__class__)
		raise e	

# To prevent casual interception/hacking, the cmd messages
# are xor'd with the node admin key. The messages are base64-encoded.
# Note: this is _not_ cryptographically secure... if you're concerned
# about that you shouldn't be doing whatever it is you're doing
# with this program.
def decrypt_msg(data, key):
	log.debug("entering decrypt_msg")
	log.debug("msg: %s", data)
	data_bytes = data.encode("UTF-8")
	msg_bytes = base64.b64decode(data_bytes)
	msg_x = msg_bytes.decode("UTF-8")
	msg = ''.join(chr(ord(x) ^ ord(y)) for (x,y) in zip(msg_x, cycle(key)))
	log.debug("msg: %s", msg)
	return msg

######## MAIN PROGRAM ########

# node_mon_list
# node_mon_list = { NODE : node_status{} , .... }
node_mon_list = { }

# Helpers
rern = re.compile(r'\r\n', re.MULTILINE)
rens = re.compile(r'\s', re.MULTILINE)

# Tunables
__MAX_MSG_LEN = 256

# Args and Log Setup
try:


	while main_loop:
		while inner_loop:
			try:
				log.debug("Waiting for a message in ZMQ")
				message_b = cmdqueue.recv()
				message = decrypt_msg(message_b.decode(), ASL_PASS)
				if len(message) > __MAX_MSG_LEN:
					log.error("message > len(%d) was ignored", __MAX_MSG_LEN)
					cmdqueue.send("ERR: cmd > %d chars not permitted", __MAX_MSG_LEN).encode("UTF-8")
					continue

				if not re.match("^(core|iax2|rpt|voter)", message):
					log.error("unsupported command: %s", message)
					cmdqueue.send("ERR: last command not a supported type".encode("UTF-8"))
					continue

				response = asl_cmd(asl, message)
				log.debug("Sending a message in ZMQ")
				cmdqueue.send(response.encode("UTF-8"))

			except BrokenPipeError as e:
				log.error("received BrokenPipeError; trying to reconnect")
				inner_loop = False
			except socket.timeout as e:
				log.error("received socket.timeout; trying to reconnect")
				inner_loop = False
			except ConnectionResetError as e:
				log.error("received ConnectionResetError; trying to reconnect")
				inner_loop = False


		# If we exited out of inner_loop without throwing an exception
		# then something went wrong with the asl socket. Loop around
		# here trying to reconnect for the timeout interval and then
		# let the main_loop continue
	
		asl.close()
		asl_dead = True
		retry_counter = 0
	
		while asl_dead:
			log.debug("sleeping for RETRY_INTERVAL of %d", RETRY_INTERVAL)
			sleep(RETRY_INTERVAL)
			retry_counter += 1
	
			if RETRY_COUNT == -1 or RETRY_COUNT <= retry_counter:
				log.debug("attempting reconnection retry #%d", retry_counter)
				asl = asl_create_connection_nofail()
				if asl:
					log.info("connection reestablished after %d retries", retry_counter)
					asl_dead = False
			else:
				log.error("count not reestablish connection after %d retries - exiting", retry_counter)
				sys.exit(1)
	
		# re-enable the innter loop processing	
		inner_loop = True

		# Close and recreate the ZMQ listener
		log.info("Recreating ZMQ listener after connection reset")
		cmdqueue.close();
		c_context = zmq.Context()
		cmdqueue = c_context.socket(zmq.REP)
		cmdqueue.bind("tcp://*:%d" % (ZMQ_PORT))
