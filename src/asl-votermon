#!/usr/bin/python3
# asl-votermon.py - Monitor ASL Asterisk server for voter module status
#
# Copyright(C) 2023 AllStarLink
# Allmon3 and all components are Licensed under the AGPLv3
# see https://raw.githubusercontent.com/AllStarLink/Allmon3/develop/LICENSE
#

import asyncio
import argparse
import configparser
from datetime import datetime
import logging
import logging.handlers
import os
import re
import signal
import socket
import sys
from time import sleep
import time
import uuid
from websockets.server import serve

_BUILD_ID = "@@HEAD-DEVELOP@@"

class LoggerAdapter(logging.LoggerAdapter):
	"""Add connection ID and client IP address to websockets logs."""
	def process(self, msg, kwargs):
		try:
			websocket = kwargs["extra"]["websocket"]
		except KeyError:
			return msg, kwargs
		xff = websocket.request_headers.get("X-Forwarded-For")
		return f"{websocket.id} {xff} {msg}", kwargs

# Handle Signals
def sigterm_handler(_signo, _stack_frame):
	log.info("exiting on signal %d", _signo)
	sys.exit(0)	
signal.signal(signal.SIGINT, sigterm_handler)
signal.signal(signal.SIGHUP, sigterm_handler)
signal.signal(signal.SIGTERM, sigterm_handler)

# Creating and connecting to the ASL manager socket

## Use this creator as part of a retry interval
def asl_create_connection_nofail():
	return asl_create_connection(False)

## Use this creator to fail immediately on any
## network-level connect failure
def asl_create_connection_fail():
	return asl_create_connection(True)

## If failhard=True then sys.exit() is called on network-level issues
def asl_create_connection(failhard):
	log.debug("asl_create_connection(failhard=%s)", failhard)
	try:
		log.debug("connect() using %s:%s", ASL_HOST, ASL_PORT)
		nasl = socket.create_connection((ASL_HOST, ASL_PORT), timeout=5)

		# Check this connected to an Asterisk Call Manager (ACM)
		part = nasl.recv(1024).decode("UTF-8")
		log.debug("AIM version: %s", rern.sub("",part))

		if not re.match("^Asterisk Call Manager", part):
			log.error("Connection to %s:%d does not appear to be an Asterisk Call Manager", ASL_HOST, ASL_PORT)
			nasl.close()
			sys.exit(1)
	
		# Logon to the ACM
		logon = "ACTION: LOGIN\r\nUSERNAME: %s\r\nSECRET: %s\r\nEVENTS: 0\r\n" % ( ASL_USER, ASL_PASS )

		logon_response = asl_cmd_response(nasl, logon)
		log.debug(rern.sub(" ",logon_response))
		lp = re.compile('Response: Success\r\n', re.MULTILINE)
		logon_success = lp.match(logon_response)
		if not logon_success:
			lr = rern.sub("  ", logon_response)
			log.error("Logon failure msg=(%s)", lr)
			asl.close()
			sys.exit(1)

		log.debug("leaving asl_create_connection()")
		return nasl

	except socket.error as error:
		log.error("connection failed to %s:%s: %s", ASL_HOST, ASL_PORT, error)
		if failhard:
			sys.exit(1)
		else:
			return None
	except TypeError as e:
		log.error("failed connection on connect(): %s", e)

		if failhard:
			sys.exit(1)
		else:	
			return None


# Generic construct for sending ASL Manager commands and reading responses
def asl_cmd_response_asl(cmd):
	return asl_cmd_response(asl, cmd)

def asl_cmd_response(s, cmd):
	try:
		aid = uuid.uuid4()
		cmd += "ActionID: %s\r\n\r\n" % aid
		s.settimeout(5)
		if not cmd is None:
			log.debug("command >> %s", rern.sub(" ", cmd))
			s.sendall(str.encode(cmd))
		
		cont_recv = True
		resp = ""
		while cont_recv:		
			part = s.recv(1024)
			if part == b'':
				log.debug("asl_cmd_response() socket went away on the far side")
				raise BrokenPipeError("other side went away")
			resp += part.decode("UTF-8")
			if resp[-4:] == "\r\n\r\n":
				cont_recv = False

		log.debug("response >> %s", rern.sub("  ", resp))
		return resp

	except TimeoutError as e:
		log.error("asl_cmd_response() TimeoutError")
		raise e
	except BrokenPipeError as e:
		log.error("asl_cmd_response() BrokenPipeError")
		raise e
	except socket.timeout as e:
		log.error("asl_cmd_response() socket.timeout")
		raise e
	except ConnectionResetError as e:
		log.error("asl_cmd_response() ConnectionResetError")
		raise e
	except Exception as e:
		log.error("asl_cmd_response() Exception: %s", e.__class__)
		log.error("asl_cmd_response() Message: %s", e)
		raise e

# (try) to logout of ASL Manager neatly
def asl_logout(s):	
	try:
		s.sendall(str.encode("ACTION: Logoff\r\n\r\n"))
	except Exception as e:
		log.error(e)

def parse_voter_data(response):
	log.debug("entering parse_voter_data()")
	# voters = { VOTED : None , VOTERS : { clientid : RSSI , .... } }
	voters = { "VOTED" : None , "VOTERS" : {} } 
	curr_client = 0
	lines = re.split(r'[\n\r]+', response)
	for line in lines:
		if re.match(r'^Client', line):
			client = re.split(r":\s", line)
			curr_client = client[1]
			voters["VOTERS"][curr_client] = 0
		elif re.match(r'^RSSI', line):
			rssi = re.split(r":\s", line)
			voters["VOTERS"][curr_client] = int(rssi[1])
		elif re.match(r'Voted', line):
			voted = re.split(r":\s", line)
			voters["VOTED"] = voted[1]

	voter_html = ""
	for n, r in voters["VOTERS"].items():
		rssipct = 0
		if r == 255:
			rssipct = 100
		else:
			rssipct = int(r) * .35 + 10

		barcolor = "primary"
		if n == voters["VOTED"]:
			barcolor = "success"
		if re.match(r"\s[Mm]ix", n):
			barcolor = "info"

		voter_html += "<div class=\"row justify-content-md-center\">"
		voter_html += "  <div class=\"col-4 col-md-2 text-end\">"
		voter_html += "    <b>{}</b>".format(n)
		voter_html += "  </div>"
		voter_html += "  <div class=\"col-8 col-md-10\">"
		voter_html += "    <div class=\"progress\" role=\"progressbar\" aria-valuenow=\"{}\"".format(rssipct)
		voter_html += "    aria-valuemin=\"0\" aria-valuemax=\"100\">"
		voter_html += "      <div class=\"progress-bar progress-bar-striped bg-{}\" style=\"width: {}%\">{}</div>".format(barcolor, rssipct, r)
		voter_html += "    </div>"
		voter_html += "  </div>"
		voter_html += "</div>"	


	voter_html += "<div class=\"row d-flex align-items-center\">"
	voter_html += "  <div class=\"col-2\">&nbsp</div>"
	voter_html += "  <div class=\"col-8\">"
	voter_html += "    Last Update: {}".format(datetime.now())
	voter_html += "  </div>"
	log.debug("exiting parse_voter_data()")	

	return voter_html

async def getVoter(websocket, ws_uri):
	log.debug("enter getVoter()")
	ready_to_fetch = True
	async for message in websocket:

		if message != ASL_PASS:
			log.error("Voter request invalid password")
			return False
		if ready_to_fetch:
			log.debug("ready_to_fetch")
			try:
				voterstatus_cmd = "ACTION: VoterStatus\r\nNODE: %d\r\n" % ( args.node )
				voterstatus_response = asl_cmd_response_asl(voterstatus_cmd)
				voter_json = parse_voter_data(voterstatus_response)
				await websocket.send(voter_json)
		
			except BrokenPipeError as e:
				log.error("received BrokenPipeError; trying to reconnect")
				ready_to_fetch = False
			except socket.timeout as e:
				log.error("received socket.timeout; trying to reconnect")
				ready_to_fetch = False
			except ConnectionResetError as e:
				log.error("received ConnectionResetError; trying to reconnect")
				ready_to_fetch = False

			log.debug("done with fetch")
		else:
			asl.close()
			asl_dead = True
			retry_counter = 0
			await websocket.send("Error connecting to AMI Voter... retry....")	
			while asl_dead:
				log.debug("sleeping for RETRY_INTERVAL of %d", RETRY_INTERVAL)
				sleep(RETRY_INTERVAL)
				retry_counter += 1
		
				if RETRY_COUNT == -1 or RETRY_COUNT <= retry_counter:
					log.debug("attempting reconnection retry #%d", retry_counter)

				asl = asl_create_connection_nofail()
				if asl:
					log.info("connection reestablished after %d retries", retry_counter)
					asl_dead = False
				else:
					log.error("count not reestablish connection after %d retries - exiting", retry_counter)
					sys.exit(1)
	
				ready_to_fetch = True

async def serverWebSocket():
	log.debug("enter ServerWebSocket()")
	async with serve(getVoter, host=None, port=WS_PORT, logger=log):
		await asyncio.Future()

######## MAIN PROGRAM ########

# Global Vars
# Helpers
rern = re.compile(r'\r\n', re.MULTILINE)

# Args and Log Setup
ap = argparse.ArgumentParser(description="Connect to an ASL Asterisk server and gather voter stats")
ap.add_argument("node", type=int, help="Node ID")
ap.add_argument("--config", help="path to INI configuration for the node")
ap.add_argument("--debug", help="enable debug-level logging output", action="store_true")
ap.add_argument("--version", help="get the version of the software", action="version", version='%(prog)s {}'.format(_BUILD_ID))
args = ap.parse_args()

log = logging.getLogger("asl-votermon")
lh = logging.StreamHandler()
lf = logging.Formatter(fmt="%(name)s: %(levelname)s: %(message)s")
lh.setFormatter(lf)
log.addHandler(lh)

if args.debug:
	log.setLevel(logging.DEBUG)
else:
	log.setLevel(logging.INFO)

if not 1 <= args.node <= 9999999:
	log.error("provided node \"%s\" must be a number between 1 and 9999999", args.node)
	sys.exit(1)
else:
	log.debug("using node %d", args.node)

if args.config:
	config_file = args.config
else:
	config_file = "/etc/allmon3/voter.ini"

# Parse configuration

try:
	if not os.path.exists(config_file):
		raise Exception("file not found: %s" % (config_file))
	log.debug("config file is %s", config_file)
	config = configparser.ConfigParser()
	config.read(config_file)
	log.debug({section: dict(config[section]) for section in config.sections()})

	if str(args.node) not in config:
		raise Exception("No configuration stanza for node %s in %s" % (args.node, config_file))
	
	if not "host" in config[str(args.node)]:
		raise Exception("Missing required attribute host= for %s in %s" % (args.node, config_file))
	ASL_HOST = config[str(args.node)]["host"]
	log.debug("ASL_HOST - %s", ASL_HOST)

	if not "user" in config[str(args.node)]:
		raise Exception("Missing required attribute user= for %s in %s" % (args.node, config_file))
	ASL_USER = config[str(args.node)]["user"]
	log.debug("ASL_USER - %s", ASL_USER)

	if not "pass" in config[str(args.node)]:
		raise Exception("Missing required attribute pass= for %s in %s" % (args.node, config_file))
	ASL_PASS = config[str(args.node)]["pass"]
	log.debug("ASL_PASS - %s", ASL_PASS)

	if not "port" in config[str(args.node)]:
		log.debug("No port= attribute specified, using default 5038")
		ASL_PORT = 5038
	else:
		ASL_PORT = int(config[str(args.node)]["port"])
		log.debug("ASL_PORT - %s", ASL_PORT)

	if not "retryinterval" in config[str(args.node)]:
		log.info("No retryinterval= attribute specified, using default 15s")
		RETRY_INTERVAL = 15
	else:
		RETRY_INTERVAL = int(config[str(args.node)]["retryinterval"])
		log.debug("RETRY_INTERVAL - %s", RETRY_INTERVAL)

	if not "retrycount" in config[str(args.node)]:
		log.info("No retrycount= attribute specified, using default of infinite retries")
		RETRY_COUNT = -1
	else:
		RETRY_COUNT = int(config[str(args.node)]["retrycount"])
		log.debug("RETRY_COUNT - %s", RETRY_COUNT)

	if not "vmonport" in config[str(args.node)]:
		raise Exception("Missing required attribute vmonport= for %s in %s" % (args.node, config_file))
	WS_PORT = int(config[str(args.node)]["vmonport"])
	log.debug("WS_PORT - %s", WS_PORT)

except Exception as e:
	log.error("INI parser error: %s", e)
	sys.exit(1)

# Create the initial connection to the ASL Manager
asl = asl_create_connection_fail()
log.debug("have original asl object")
log.debug("starting the main work loop")
last_db_update = time.time()
try:
	asyncio.run(serverWebSocket())

except Exception as e:
	log.error(e)
	raise e

finally:
	log.debug("Clean up on aisle 5")
	asl_logout(asl)
	asl.close()

sys.exit(0)
